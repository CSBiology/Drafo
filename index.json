[{"uri":"/Drafo/Drafo.html","title":"Drafo","content":"(***hide***)\n\n\n\n#r \u0022nuget: Deedle, 2.5.0\u0022\n#r \u0022nuget: FSharp.Stats, 0.4.3\u0022 \n#r \u0022nuget: FSharpAux, 1.1.0\u0022 \n#r \u0022nuget: DynamicObj, 1.0.1\u0022 \n#r \u0022../bin/Drafo/netstandard2.0/Drafo.dll\u0022\n\n\nopen Deedle\nopen FSharp.Stats\nopen FSharpAux\nopen Drafo.Core\n\n(**\n## seriesToFrame \nThe function \u0060seriesToFrame\u0060 takes a Series of the type \u0060\u003CKey,\u0027a\u003E\u0060 and turnes it into a Frame of the type \u0060\u003Cint,string\u003E\u0060. \nThe function applies the value part of the \u0060Key\u0060 as values in its own Column called \u0060Values\u0060. The key part of the \u0060Key\u0060 is turned into column names\nTo get the Key type back in the Frame you can vor example index it with the \u0060indexWithColumnValues\u0060 function\n*)\n\nlet newKeyTest str a = Key().addCol(str,a)\nlet seriesForFrame:Series\u003CKey,_\u003E = \n  [\n    (newKeyTest \u0022One\u0022 4.).addCol (\u0022Two\u0022,2.), 1.\n    (newKeyTest \u0022One\u0022 2.).addCol (\u0022Two\u0022,5.), 2.\n  ]\n  |\u003Eseries\n\nlet seriesToFrameTest = seriesToFrame seriesForFrame \n\nseriesToFrameTest.Print()\n\n(***include-output***) \n(**\n## indexWithColumnValues\nThe function \u0060indexWithColumnValues\u0060 takes the column keys defined in a Series that is provided and values in these columns and applies them as Keys into the Rows. The original column keys are maintained.\n*)\n\nlet seriesToFrameTestIndexed = seriesToFrame seriesForFrame |\u003E indexWithColumnValues [\u0022One\u0022; \u0022Two\u0022]\n\nseriesToFrameTestIndexed.Print()\n\n(***include-output***) \n(**\n## getColumn\nThe \u0060getColumn\u0060 function gets a single column of the frame. It needs the exact name of the column key. \n*)\nlet getColumn2: Series\u003CKey,string\u003E = getColumn \u0022Two\u0022 seriesToFrameTestIndexed\n\ngetColumn2.Print()\n\n(***include-output***) \n(**\n\n## rowKeyToColumns\nThe function \u0060rowKeyoColumns\u0060 shifts the row keys of type Key into the columns and become strings. The value part of the Key type gets put into the new columns\n*)\n\nlet exmpColMajorFrameTwo =\n  frame [\n    ( \u0022c1,T1,r1\u0022 )=\u003E series [(newKeyTest\u0022row1\u0022 1.).addCol (\u0022row2\u0022, 3.),3.]\n    ( \u0022c2,T1,r1\u0022 )=\u003E series [(newKeyTest\u0022row1\u0022 10.).addCol(\u0022row2\u0022 ,100.),100.]\n  ]\n\nexmpColMajorFrameTwo.Print()\n\nlet testRowToColumnKey = rowKeyToColumns exmpColMajorFrameTwo\n\ntestRowToColumnKey.Print() \n\n(***include-output***) \n(**\n## createFilter\nThe function \u0060createFilter\u0060 needs a function that takes a input and gives a bool and a series of \u0060\u003CKey,_\u003E\u0060(most often a single column). It then gives a Series of \u0060\u003CKey,bool\u003E\u0060 \nthat can be used in later functions as filter. \n*)\n\nlet boolFunction a = \n  if a \u003E 1. then true\n  else false\n\nlet letsCreateAFilter = createFilter boolFunction seriesForFrame\n\nletsCreateAFilter.Print()\n\n(***include-output***) \n(**\n## transform\nThe \u0060transform\u0060function needs a function that turns \u0027a into \u0027b and a series that has the \u0060\u003CKey,_\u003E\u0060 type (most often a single column) to transform your data\n*)\n\nlet transformFuction a= \n  if a = 1. then 0.\n  else a\n\nlet letsTransformSomeSeries = transform transformFuction seriesForFrame\n\nletsTransformSomeSeries.Print()\n\n(***include-output***) \n(**\n## zip\nthe \u0060zip\u0060 function needs a function that takes two parameters and two series of type \u0060\u003CKeytype,\u0027a\u003E\u0060 (most often a single column) which then zippes depending on the function used\n*)\n\nlet getColumnOne = exmpColMajorFrameTwo|\u003E getColumn\u003Cfloat\u003E \u0022c1,T1,r1\u0022\n\nlet getColumnTwo= exmpColMajorFrameTwo|\u003E getColumn\u003Cfloat\u003E \u0022c2,T1,r1\u0022\n\nlet zipped = zip (fun x y -\u003E x / y) getColumnOne getColumnTwo\n\nzipped.Print()\n\n(***include-output***) \n(**\n## dropKeyColumns and dropAllKeyColumnsBut\n\n\u0060dropKeyColumns\u0060 and \u0060dropAllKeyColumnsBut\u0060 takes a sequence of column keys and a Key. \nthe sequences should in the first case contain all columns that need to be dropped and in the second option all columns that will be kept\n// the Key can contain any number of keys from which keys can be dropped\n*)\n\nlet seriesForPropertyDrop = seq [\u0022c1,T1,r1\u0022;\u0022c2,T1,r1\u0022;\u0022c2,T1,r3\u0022]\n\nlet keyForPropertyDrop = ( newKeyTest \u0022c1,T1,r1\u0022 0).addCol (\u0022LLLL\u0022,9)\n\n\nlet dropsProperty = dropKeyColumns seriesForPropertyDrop keyForPropertyDrop\n\nlet dropsAllPropBut =dropAllKeyColumnsBut seriesForPropertyDrop keyForPropertyDrop\n\nprintfn(\u0022%O\u0022)dropsProperty\nprintfn(\u0022%O\u0022) dropsAllPropBut\n\n(***include-output***) \n\n(**\n## group functions\n\nThe \u0060groupTransform\u0060 functions takes a function of \u0060op :\u0027a [] -\u003E \u0027a -\u003E \u0027b\u0060, in this case the \u0060dropAllKeyColumnsBut\u0060 function a \u0060Seq\u003Cstring\u003E and a Series\u003C\u0027KeyType, \u0027a\u003E\u0060. \nDepending on the function used the series gets transformed. While the \u0060groupFilter\u0060 is a special version of it that uses \u0060groupTransform\u0060 and needs\n\u0060op :\u0027a [] -\u003E \u0027a -\u003E bool\u0060.\n\n*)\n\nlet seriesForFrameFloat:Series\u003CKey,_\u003E = \n  [\n    (newKeyTest \u0022Two\u0022 4).addCol (\u0022One\u0022,2), 1.\n    (newKeyTest \u0022Two\u0022 2).addCol (\u0022One\u0022,5), 2.\n    (newKeyTest \u0022Two\u0022 2).addCol (\u0022One\u0022,7), 3. \n  ]\n  |\u003Eseries\n\nlet seriesForPropertyDropMod = seq [\u0022Two\u0022]\n\nlet operation = \n  fun (x:seq\u003Cfloat\u003E) -\u003E \n  let m = Seq.mean x\n  fun x -\u003E x - m\n\nlet tryGroupsTransform = groupTransform operation dropAllKeyColumnsBut seriesForPropertyDropMod seriesForFrameFloat\n\ntryGroupsTransform.Print()\n\nlet opFilter= \n  fun values -\u003E \n  let mean = Seq.mean values\n  (fun values -\u003E values \u003C= mean)\n\nlet tryGroupsFilter = createGroupFilter opFilter dropAllKeyColumnsBut seriesForPropertyDropMod seriesForFrameFloat\n\ntryGroupsFilter.Print()\n\n(***include-output***) \n\n(**\n## aggregate\n\nThe \u0060aggregate\u0060 function uses a created filter to filter the given series of \u0060\u003CKey,\u0027a\u003E\u0060 and everything that is not true is dropped. In this case only the first row is kept.\nThen either \u0060dropKeyColumns\u0060 or \u0060dropAllKeyColumnsBut\u0060 or a user defined function is applied to the filtered series that was turned into a frame. In the end \nthe op function is applied\n*)\n\nlet letsTransformAFilter = seq [(createFilter boolFunction seriesForFrameFloat)]\n\nlet op =fun (x:seq\u003Cfloat\u003E) -\u003E Seq.mean x\n\nlet aggregations = aggregate op dropAllKeyColumnsBut seriesForPropertyDropMod letsTransformAFilter seriesForFrameFloat\n\naggregations.Print()\n\n(***include-output***) \n\n(**\n## assemble\n\u0060assemble\u0060 takes a sequence of Series and creates a frame\n*)\n\nlet forKeySeriesOne:Series\u003C_,int\u003E = seq [(newKeyTest\u0022Two\u0022 1).addCol(\u0022T\u0022,2), 6;(newKeyTest\u0022Two\u0022 3).addCol(\u0022T\u0022,5), 9]|\u003Eseries\n\nlet forKeySeriesTwo:Series\u003C_,int\u003E = seq [(newKeyTest\u0022Two\u0022 1).addCol(\u0022T\u0022,2), 6;(newKeyTest\u0022Two\u0022 3).addCol(\u0022T\u0022,5), 9]|\u003Eseries\n\nlet assembly = \n  assemble \n    [\n      \u0022One\u0022,forKeySeriesOne:\u003EISeries\u003CKey\u003E\n      \u0022Two\u0022,forKeySeriesTwo:\u003EISeries\u003CKey\u003E\n    ]\n\nassembly.Print()\n\n(***include-output***) \n\n(**\n## pivot\n\n\u0060pivot\u0060 is a function that takes a string and a Frame. The string decides which row \u0060Key\u0060 is applied to the column key, the value part is applied. \nThe values in rows that were deleted are moved into the still existing rows\n*)\n\nlet testString =\u0022One\u0022\n\nlet testPivot = pivot testString seriesToFrameTestIndexed\n\ntestPivot.Print()\n\n(***include-output***) \n\n(**\n## module NumericAggregation\n\u0060NumericAggregation\u0060 does either the mean, median or float based on your input. For that it needs a Frame\nof \u0060\u003CKey,_\u003E\u0060 a fliter, a \u0060\u003Cseq \u003CSeries \u003CKey,bool\u003E\u003E\u003E\u0060 or a \u0060\u003Cseq \u003Cseq \u003CSeries \u003CKey,bool\u003E\u003E\u003E\u003E\u0060, that say which values should be aggregated and for a singel column a string\nThe module has two functions either \u0060numAgAllCol\u0060that aggregates over all columns or \u0060numAggregat\u0060that agggregates one column\nThe result is a Frame\u003CKey,string\u003E\n*)\n\n(**\n## module NumericFilter\n\u0060NumericFilter\u0060 is a module that can say if values in a given column are bigger or smaller than a given value.\nThe resultant series of the type \u0060\u003CKey,bool\u003E\u0060.\nThe input Frame needs to be of the type Frame\u0060\u003CKey,_\u003E\u0060.\nThe module has one function for all columns in a frame: \u0060numericFilterServeralCol\u0060 and one for a single \u0060columnnumericFilter\u0060 which also needs a string to determine the column\n*)\n\n(**\n## module NumericTransform\nThe \u0060NumericTransform\u0060 has five operations that can be done on all values in either a column(series) or a frame:\n| Log2\n| Subtract\n| Add \n| DivideBy \n| MultiplyBy \n\nThese are can be either used on a full frame, \u0060numericTransformAllCols\u0060, or on a single column, \u0060numericTransformOneCol\u0060.\nBoth need a Frame of the type \u0060\u003CKey,_\u003E\u0060 and a seq\u003Cstring\u003E, to determine which columns are dropped but \u0060numericTransform\u0060 \nneeds a string to determine the column.\n*)\n\n(**\n## moduleGroupWiseNumericTransform\n\nThe \u0060GroupWiseNumericTransform\u0060 has four operations:\n| DivideByMedian\n| DivideByMean \n| SubtractMedian\n| SubtractMean \n\nThese are can be either used on a full frame,\u0060groupWiseNumericTransformAllCols\u0060 , or on a single column, \u0060groupWiseNumericTransform\u0060.\nBoth need a Frame of the type \u0060\u003CKey,_\u003E\u0060 and a seq\u003Cstring\u003E, to determine which columns are dropped but \u0060groupWiseNumericTransform\u0060 \nneeds a string to determine the column.\n*)\n\n(**\n## module GroupFilter \n\n\u0060Groupfilter\u0060 filters the given Frame of \u0060\u003CKey,_\u003E\u0060. If a value of a Series (column), is either a bigger or lower than the given Tukey or stdev of the series than the bool is \u003Cfalse\u003E otherwise it is \u003Ctrue\u003E\nThe end result is a Series of Key true/false pairs or a seq of series \u0060\u003CKey,bool\u003E\u0060 for the variant that iterates over the entire frame.\n\u0060groupFilter\u0060 only uses one column of a Frame and \u0060groupFilterAllCol\u0060iterats over the entire frame\n*)\n\n(**\n## module StringAggregation\n\nStrinAggregation concatenates string in the provide Series of \u0060\u003CKey,string\u003E\u0060.\nThis happens based on the filter provided. \n\u0060stAggregate\u0060 only uses one column of a Frame and \u0060stAggregateFullFrame\u0060 iterates over the entire frame\n\n*)\n\n\n\n"},{"uri":"/Drafo/Drafo_pipeline_tutorial.html","title":"Drafo_pipeline_tutorial","content":"\n(***hide***)\n\n#r \u0022nuget: Deedle, 2.5.0\u0022\n#r \u0022nuget: FSharp.Stats, 0.4.3\u0022 \n#r \u0022nuget: FSharpAux, 1.1.0\u0022 \n\n#r \u0022nuget: DynamicObj, 1.0.1\u0022 \n#r \u0022../bin/Drafo/netstandard2.0/Drafo.dll\u0022\n\n\n\n\nopen Deedle\nopen FSharp.Stats\nopen FSharpAux\n\nopen Drafo.Core\nopen NumericFilter.NumericFilter\nopen NumericAggregation.NumericAggregation\n\n(**\n## Example workflow\n\nIf one has a csv that contains the data, the first question is whether the frame contains columns that are needed for the indexing.\nShould this be the case one can use the \u0060readAndIndexFrame\u0060, is that not the case one has first to reading the frame with \n\u0060readFrame\u0060 add the columns that are needed for indexing and then index with \u0060indexWithColumnValues\u0060. \nYou will need to index with at least 2 columns should you wish to \u0060aggregate\u0060 because then can have the same Key \nvalue pairs in one column as needed/wished for the aggregation. Each time you want to aggregate means you have to have an additional column\nfor the indexing. Keep in mind that you can use functions of the \u0060GroupTransform\u0060 module as often as you want because the row keys are not changed. In this example we go with 2 aggregations because we have biological and technical replicates. \n\n*)\n\nlet frameForTutorial = \n  frame [\n    (\u0022ConditionA\u0022)=\u003E series [\u0022row1\u0022 =\u003E 2.;\u0022row2\u0022 =\u003E3.;\u0022row3\u0022 =\u003E1.;\u0022row4\u0022 =\u003E7.]\n    (\u0022ConditionB\u0022)=\u003E series [\u0022row1\u0022 =\u003E 2.4;\u0022row2\u0022 =\u003E4.5;\u0022row3\u0022 =\u003E6.1;\u0022row4\u0022 =\u003E5.1] \n  ]\n  |\u003EFrame.addCol \u0022Gen\u0022(series [\u0022row1\u0022 =\u003E \u0022A\u0022 ;\u0022row2\u0022 =\u003E\u0022A\u0022;\u0022row3\u0022 =\u003E\u0022A\u0022;\u0022row4\u0022 =\u003E\u0022A\u0022])\n  |\u003EFrame.addCol \u0022technicalReplicate\u0022(series [\u0022row1\u0022 =\u003E \u0022B\u0022 ;\u0022row2\u0022 =\u003E\u0022B\u0022;\u0022row3\u0022 =\u003E\u0022C\u0022;\u0022row4\u0022 =\u003E\u0022C\u0022])\n  |\u003EFrame.addCol \u0022BioRep\u0022(series [\u0022row1\u0022 =\u003E \u0022D\u0022 ;\u0022row2\u0022 =\u003E\u0022E\u0022;\u0022row3\u0022 =\u003E\u0022D\u0022;\u0022row4\u0022 =\u003E\u0022E\u0022])\n\n\n\nlet indexedTutorialFrame = indexWithColumnValues [\u0022Gen\u0022;\u0022technicalReplicate\u0022;\u0022BioRep\u0022] frameForTutorial\n\nindexedTutorialFrame.Print()\n\n(***include-output***) \n\n(**\n\n!!!! \nKeep in mind that the function working on the whole frame will error should \nyou have strings as values inside the frame for the \u0060NumericAggregation\u0060 function or ints/floats for the \u0060StringAggregation\u0060.\nSo remove the values/columns or use the single column versions multiple times.\n!!!!\n\n*)\n\nlet indexedFrameWithoutIndexingColumns = \n  indexedTutorialFrame\n  |\u003EFrame.dropCol \u0022Gen\u0022\n  |\u003EFrame.dropCol \u0022technicalReplicate\u0022\n  |\u003EFrame.dropCol \u0022BioRep\u0022\n\nindexedFrameWithoutIndexingColumns.Print()\n\n(***include-output***) \n\n(**\n\nAs you can see each row has multiple Key objects and the combinations are unique.\nNow one can create a filter with either the \u0060NumericFilter\u0060 or \u0060GroupFilter\u0060 module functions.\nto use the resultant series\u003CKey,bool\u003E or seq series\u003CKey,bool\u003E one has to keep in mind that the functions in the \n\u0060NumericAggregation\u0060 and \u0060StringAggregation\u0060 modules need for each column a seq of series\u003CKey,bool\u003E, so one needs \nto create a seq of seq of series\u003CKey,bool\u003E for the function that affect the whole frame. If not done correctly this could\nresult in an error(an empty filter is not suitable for the functions working on the whole frame!).\nWhen you have a suitable seq of series\u003CKey,bool\u003E or seq of seq of series\u003CKey,bool\u003E then one can then use \nthe aggregation module of choice. \nLet\u0027s look back at our example with filters that filters would always say true, we want the Mean, and we use the seq [\u0022Gen\u0022;\u0022technicalReplicate\u0022] to determine that Rep. \n\n*)\n\nlet filterA = numericFilterServeralCol (IsBiggerThan 0.5) indexedFrameWithoutIndexingColumns\nlet filterB = numericFilterServeralCol (IsSmallerThan 100.) indexedFrameWithoutIndexingColumns\n\nlet seqOfFilterMulty filterOne filterTwo = \n  filterOne\n  |\u003ESeq.mapi (fun i x -\u003E \n    let colKeysForSeq seqIt b= \n      seqIt\n      |\u003ESeq.item b\n    let cIII = seq [x;colKeysForSeq filterTwo i]\n    cIII)\n\nlet aggregatedFrameA = numAgAllCol Mean indexedFrameWithoutIndexingColumns [\u0022Gen\u0022;\u0022technicalReplicate\u0022] (seqOfFilterMulty filterA filterB)\naggregatedFrameA.Print()\n\n(***include-output***) \n\n(**\nAs you can see the \u0060BioRep\u0060 parts of the keys was dropped and we aggregated Keys that were identical. \nNow we also want to do the median of the \u0060technicalReplicate\u0060. For that we need new filters and need to adjust the input parameters.\n\n*)\n\nlet filterC = numericFilterServeralCol (IsBiggerThan 0.5) aggregatedFrameA \nlet filterD = numericFilterServeralCol (IsSmallerThan 100.) aggregatedFrameA \n\nlet aggregatedFrameB = numAgAllCol Median aggregatedFrameA [\u0022Gen\u0022] (seqOfFilterMulty filterC filterD)\n\naggregatedFrameB.Print()\n\n(***include-output***)"},{"uri":"/Drafo/index.html","title":"Drafo documentation\n","content":"(***hide***)\n\n#r \u0022nuget: Deedle, 2.5.0\u0022\n#r \u0022nuget: FSharp.Stats, 0.4.3\u0022 \n#r \u0022nuget: FSharpAux, 1.1.0\u0022 \n\n#r \u0022nuget: DynamicObj, 1.0.1\u0022 \n#r \u0022../bin/Drafo/netstandard2.0/Drafo.dll\u0022\nopen Deedle\nopen FSharp.Stats\nopen FSharpAux\n\nopen Drafo.Core\nopen NumericAggregation.NumericAggregation\n(**\n# Drafo documentation\n\nThis library adds a DynamicObject called \u003CKey\u003E that can be used as row key of Deedle frames and series. \nThe functions in this library all either create frames with \u003CKey\u003E objects or work with frames or series that have \u003CKey\u003E objects. \nThe modules allow for easy creation of filters und processing of either series or frames.\n\n#### Table of contents \n\n- [Installation](#Installation)\n- [Usage](#Usage)\n- [Example](#Example)\n\n## Installation\n\nThis library is available as nuget package(from [nuget]()):\n\n## Usage\n\nAdd the NuGet package as reference and open Drafo/Drafo.Core and any module you want to use. \nBecause Drafo is build on Deedle it is highly recommended to use Deedle too.\n\nYou can create your own frame, with \u003CKey\u003E objects as row keys, transform existing frames into frames that have \u003CKey\u003E objects \nor read in csv files and then transform them. \n\nThen one can use the functions in the Drafo core or the modules to manipulate series or frames that have \u003CKey\u003E objects as row keys.\n\n## Example \n\nWe have a frame of floats that we want to use some operations of the Drafo library on. So first we must index it, \nfor that we add columns that should be turned into \u003CKeys\u003E, should the frame not contain such columns jet.\n*)\n\nlet exampleFrame = \n  frame [\n    (\u0022Column1\u0022)=\u003Eseries [\u0022row1\u0022=\u003E2.;\u0022row2\u0022=\u003E4.5;\u0022row3\u0022=\u003E3.7;\u0022row4\u0022=\u003E2.9]\n    (\u0022Column2\u0022)=\u003Eseries [\u0022row1\u0022=\u003E4.;\u0022row2\u0022=\u003E5.5;\u0022row3\u0022=\u003E6.9;\u0022row4\u0022=\u003E5.]\n  ]\n\nlet exampleFrameWithKeyCols =\n  exampleFrame\n  |\u003EFrame.addCol \u0022Gen\u0022(series [\u0022row1\u0022=\u003E\u0022A\u0022;\u0022row2\u0022=\u003E\u0022A\u0022;\u0022row3\u0022=\u003E\u0022A\u0022;\u0022row4\u0022=\u003E\u0022A\u0022])\n  |\u003EFrame.addCol \u0022TecRep\u0022(series [\u0022row1\u0022=\u003E\u0022B\u0022;\u0022row2\u0022=\u003E\u0022B\u0022;\u0022row3\u0022=\u003E\u0022C\u0022;\u0022row4\u0022=\u003E\u0022C\u0022])\n  |\u003EFrame.addCol \u0022BioRep\u0022(series [\u0022row1\u0022=\u003E\u0022D\u0022;\u0022row2\u0022=\u003E\u0022E\u0022;\u0022row3\u0022=\u003E\u0022D\u0022;\u0022row4\u0022=\u003E\u0022E\u0022])\n\nlet indexedFrameWithKeyCols = indexWithColumnValues [\u0022Gen\u0022;\u0022TecRep\u0022;\u0022BioRep\u0022] exampleFrameWithKeyCols\n\nindexedFrameWithKeyCols.Print()\n\n(***include-output***) \n\n(**\nas you can see, we have now a multi-tiered \u003CKey\u003E for each row that is unique. From this point, one can go in several directions.\nFor example, one could subtract or add to all values in a series (Column) with the \u0060transform\u0060 function or one could create \nfilters with the modules \u0060GroupFilter\u0060 or \u0060NumericFilter\u0060 or the \u0060filter\u0060 function. Here we want to aggregate a single column. \n*)\n\nlet singleColumnAggregateMean = numAggregat Mean indexedFrameWithKeyCols \u0022Column1\u0022 [\u0022Gen\u0022;\u0022TecRep\u0022] (seq [])\n\nsingleColumnAggregateMean.Print()\n\n(***include-output***)\n"}]